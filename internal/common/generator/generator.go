// +build !excludecodegen

/*
Copyright IBM Corporation 2020

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This program generates dockerfiles.go. It can be invoked by running
// go generate
package main

import (
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/konveyor/move2kube/internal/common"
	log "github.com/sirupsen/logrus"
)

// Reads all non .go files in the current directory
// and encodes them as strings literals in <directoryname>.go

const (
	license = `/*
Copyright IBM Corporation 2020

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/`

	conststemp = `// Code generated by go generate; DO NOT EDIT.

` + license + `

package {{ .Directory }}

const (
{{	range $file, $contents := .Files  }}
	{{ $file }} = ` + "`{{ $contents }}`" + `
{{ end }}
)`

	maptemp = `// Code generated by go generate; DO NOT EDIT.

` + license + `

package {{ .Directory }}

var Constants= map[string]string{
{{	range $file, $contents := .Files  }}
	` + "`{{ $file }}`" + ` : ` + "`{{ $contents }}`," + `
{{ end }}
}`

	tartemp = `// Code generated by go generate; DO NOT EDIT.

` + license + `

package {{ .Directory }}

const Tar =  ` + "`{{ .TarString }}`"
)

//TODO: Fix cases where the file has ` in contents
func main() {
	directory := os.Args[1]
	if len(os.Args) == 3 {
		if os.Args[2] == "makemaps" {
			if err := makeConstants(directory, maptemp); err != nil {
				log.Fatalf("Error during code gen on directory %q with makemaps Error: %q", directory, err)
			}
		} else if os.Args[2] == "maketar" {
			if err := makeTar(directory); err != nil {
				log.Fatalf("Error during code gen on directory %q with maketar Error: %q", directory, err)
			}
		}
	} else {
		if err := makeConstants(directory, conststemp); err != nil {
			log.Fatalf("Error during code gen on directory %q with consts template Error: %q", directory, err)
		}
	}
}

func makeConstants(directory string, tplstr string) error {
	files := map[string]string{}

	log.Infof("Generating constants from %q", directory)
	fs, err := ioutil.ReadDir(directory)
	if err != nil {
		log.Errorf("Failed to read the directory %q Error: %q", directory, err)
		return err
	}
	for _, f := range fs {
		file := f.Name()
		if f.IsDir() {
			continue
		}
		if !strings.HasSuffix(file, ".go") && !strings.HasPrefix(file, ".") {
			currpath := filepath.Join(directory, file)
			content, err := ioutil.ReadFile(currpath)
			if err != nil {
				log.Errorf("Failed to read the file at path %q Error: %q", currpath, err)
				return err
			}
			// Convert []byte to string
			files[strings.ReplaceAll(file, ".", "_")] = string(content)
		}
	}

	outputpath := filepath.Join(directory, "constants.go")
	f, err := os.Create(outputpath)
	if err != nil {
		log.Errorf("Failed to create the file at path %q Error: %q", outputpath, err)
		return err
	}
	defer f.Close()

	var tpl = template.Must(template.New("").Parse(tplstr))

	absdirectory, err := filepath.Abs(directory)
	if err != nil {
		log.Errorf("Unable to resolve full path of directory %q : %q", absdirectory, err)
		return err
	}

	err = tpl.Execute(f, struct {
		Directory string
		Files     map[string]string
	}{
		Directory: filepath.Base(absdirectory),
		Files:     files,
	})
	if err != nil {
		log.Errorf("Failed to execute the template. Error: %q", err)
		return err
	}
	return nil
}

func makeTar(directory string) error {
	outputpath := filepath.Join(directory, "constants.go")
	f, err := os.Create(outputpath)
	if err != nil {
		log.Errorf("Failed to create the file at path %q Error: %q", outputpath, err)
		return err
	}
	defer f.Close()

	log.Infof("Generating tar from %q", directory)

	tarString, err := common.TarAsString(directory, []string{"constants.go", "assets.go"})
	if err != nil {
		log.Errorf("Error while creating tar : %q", err)
		return err
	}

	var tpl = template.Must(template.New("").Parse(tartemp))

	absdirectory, err := filepath.Abs(directory)
	if err != nil {
		log.Errorf("Unable to resolve full path of directory %q : %q", absdirectory, err)
		return err
	}

	err = tpl.Execute(f, struct {
		Directory string
		TarString string
	}{
		Directory: filepath.Base(absdirectory),
		TarString: tarString,
	})
	if err != nil {
		log.Errorf("Failed to execute the template. Error: %q", err)
		return err
	}
	return nil
}
