const (
	// DockerFileContainerBuildTypeValue defines the containerization type as docker file
	DockerFileContainerBuildTypeValue ContainerBuildTypeValue = "NewDockerfile"
	// ReuseDockerFileContainerBuildTypeValue defines the containerization type as reuse of dockerfile
	ReuseDockerFileContainerBuildTypeValue ContainerBuildTypeValue = "ReuseDockerfile"
	// ReuseContainerBuildTypeValue defines the containerization type as reuse of an existing container
	ReuseContainerBuildTypeValue ContainerBuildTypeValue = "ReuseImage"
	// CNBContainerBuildTypeValue defines the containerization type of cloud native buildpack
	CNBContainerBuildTypeValue ContainerBuildTypeValue = "CNB"
	// ManualContainerBuildTypeValue defines that the tool assumes that the image will be created manually
	ManualContainerBuildTypeValue ContainerBuildTypeValue = "Manual"
	// S2IContainerBuildTypeValue defines the containerization type of S2I
	S2IContainerBuildTypeValue ContainerBuildTypeValue = "S2I"
)

const (
	

	// CfManifestArtifactType defines the source artifact type of cf manifest
	CfManifestArtifactType SourceArtifactTypeValue = "CfManifest"
	// CfRunningManifestArtifactType defines the source artifact type of a manifest of a running instance
	CfRunningManifestArtifactType SourceArtifactTypeValue = "CfRunningManifest"

)


func MapInterfaceToYamlStruct(m interface{}, t reflect.Type) (interface{}, error) {
	logrus.Debugf("Loading mapinterface %+v into %T", m, t)
	yamlString, err := yaml.Marshal(m)
	if err != nil {
		logrus.Errorf("Unable to parse mapinterface %+v as yaml string", m)
		return nil, err
	}
	s := reflect.New(t).Interface().(t.)
	err = yaml.Unmarshal(yamlString, &s)
	logrus.Debugf("Loaded config (%T) : %s", s, s)
	return err
}

	RegistryURL          string
	RegistryNamespace    string
	TargetClusterSpec    collecttypes.ClusterMetadataSpec
	IngressTLSSecretName string

	RootDir string
	Name    string



// GetFullImageName returns the full image name including registry url and namespace
func (ir *IR) GetFullImageName(imageName string) string {
	if ir.RegistryURL != "" && ir.RegistryNamespace != "" {
		return ir.RegistryURL + "/" + ir.RegistryNamespace + "/" + imageName
	}
	if ir.RegistryNamespace != "" {
		return ir.RegistryNamespace + "/" + imageName
	}
	return imageName
}



// GetContainer returns container which has the imagename
func (ir *IR) GetContainer(imagename string) (con Container, exists bool) {
	for _, c := range ir.Containers {
		if common.IsStringPresent(c.ImageNames, imagename) {
			return c, true
		} else if c.New {
			parts := strings.Split(imagename, "/")
			if len(parts) > 2 && parts[0] == ir.RegistryURL && common.IsStringPresent(c.ImageNames, parts[len(parts)-1]) {
				return c, true
			}
		}
	}
	return Container{}, false
}
